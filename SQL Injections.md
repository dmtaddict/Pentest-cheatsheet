## SQL Injections (source: Portswigger academy):
### Что такое SQL инъекции
SQL инъекции - это уязвимость веб-безопасности, которая позволяет злоумышленнику вмешиваться в запросы, которые приложение делает к своей базе данных. Как правило, это позволяет злоумышленнику просматривать данные, которые они обычно не могут получить. Это может включать данные, принадлежащие другим пользователям, или любые другие данные, к которым может получить доступ само приложение. Во многих случаях злоумышленник может изменить или удалить эти данные, что приведет к постоянным изменениям содержимого или поведения приложения.
В некоторых ситуациях злоумышленник может усилить атаку с использованием SQL-инъекции, чтобы скомпрометировать базовый сервер или другую внутреннюю инфраструктуру, или выполнить атаку с отказом в обслуживании (dos).
![](https://portswigger.net/web-security/images/sql-injection.svg)
### Какое влияние может оказать успешная SQL-инъекция?
Успешная атака с использованием SQL-инъекции может привести к несанкционированному доступу к конфиденциальным данным, таким как пароли, данные кредитной карты или личная информация пользователя. Многие громкие утечки данных в последние годы стали результатом атак с использованием SQL-инъекций, что привело к ущербу репутации и штрафам регулирующих органов. В некоторых случаях злоумышленник может получить постоянный бэкдор в системы организации, что приведет к долгосрочной эксплуатации, которая может оставаться незамеченной в течение длительного периода.
### Примеры SQL-инъекций
Существует большое разнообразие уязвимостей, атак и методов внедрения SQL, которые возникают в различных ситуациях. Некоторые распространенные примеры SQL-инъекций включают:
* Извлечение скрытых данных, где вы можете изменить SQL-запрос, чтобы вернуть дополнительные результаты.
* Подрыв логики приложения, где вы можете изменить запрос, чтобы вмешаться в логику приложения.
* *UNION* атаки, в которых вы можете извлекать данные из разных таблиц базы данных.
* Изучение базы данных, из которой можно извлечь информацию о версии и структуре базы данных.
* Слепая инъекция SQL, при которой результаты управляемого вами запроса не возвращаются в ответах приложения.
### Извлечение скрытых данных
Рассмотрим приложение для покупок, которое отображает товары в разных категориях. Когда пользователь нажимает на категорию *Gifts*, его браузер запрашивает URL-адрес:
>https://insecure-website.com/products?category=Gifts 

Это заставляет приложение выполнять SQL-запрос для получения сведений о соответствующих продуктах из базы данных:
>SELECT * FROM products WHERE category = 'Gifts' AND released = 1

Этот запрос запрашивает у базы данных следущие данные:
* все данные («*»)
* из таблицы *products*
* где категория продуктов *Gifts*
* и released is 1

Ограничение released = 1 используется для скрытия продуктов, которые не выпущены. Для неизданных продуктов, предполагается released = 0.

Приложение не реализует никаких средств защиты от атак с использованием SQL-инъекций, поэтому злоумышленник может создать атаку, подобную:
>https://insecure-website.com/products?category=Gifts'--

В результате будет следующий SQL запрос:
>SELECT * FROM products WHERE category = 'Gifts'--' AND released = 1

Ключевым моментом здесь является то, что последовательность двойных тире -- это индикатор комментариев в SQL и означает, что остальная часть запроса интерпретируется как комментарий. Это эффективно удаляет оставшуюся часть запроса, поэтому он больше не включает *AND released = 1*. Это означает, что отображаются все продукты, включая неизданные.

Идя дальше, злоумышленник может заставить приложение отображать все товары в любой категории, включая категории, о которых они не знают:
>https://insecure-website.com/products?category=Gifts'+OR+1=1--

В результате будет следующий SQL запрос:
>SELECT * FROM products WHERE category = 'Gifts' OR 1=1--' AND released = 1

Измененный запрос вернет все товары, в которых либо категория является *Gifts*, либо 1 равно 1. Поскольку 1=1 всегда истинно, запрос вернет все элементы.
### Подрыв логики приложения
Рассмотрим приложение, которое позволяет пользователям входить в систему с именем пользователя и паролем. Если пользователь вводит имя пользователя *wiener* и пароль *bluecheese*, приложение проверяет учетные данные, выполняя следующий SQL-запрос:
>SELECT * FROM users WHERE username = 'wiener' AND password = 'bluecheese'

Если запрос возвращает сведения о пользователе, то вход в систему выполнен успешно. В противном случае он отклоняется.

Здесь злоумышленник может войти в систему как любой пользователь без пароля, просто используя последовательность комментариев SQL-чтобы удалить проверку пароля из выражения *WHERE* запроса. Например, отправив имя пользователя **administrator'--** и пустой пароль, вы получите следующий запрос:
>SELECT * FROM users WHERE username = 'administrator'--' AND password = ''

Этот запрос возвращает пользователя с именем администратора и успешно регистрирует злоумышленника как этого пользователя
### Извлечение данных из других таблиц базы данных
В случаях, когда результаты SQL-запроса возвращаются в ответах приложения, злоумышленник может использовать уязвимость SQL-инъекций для извлечения данных из других таблиц базы данных. Это делается с помощью ключевого слова *UNION*, которое позволяет выполнить дополнительный запрос *SELECT* и добавить результаты к исходному запросу.

Например, если приложение выполняет следующий запрос, содержащий введимое пользователем "Gifts":
>SELECT name, description FROM products WHERE category = 'Gifts'

тогда атакующий может внедрить:
>' UNION SELECT username, password FROM users--

Это приведет к тому, что приложение вернет все имена пользователей и пароли вместе с названиями и описаниями продуктов.
#### SQL injection UNION attacks
Когда приложение уязвимо для SQL инъекций и результаты запроса возвращаются в ответах приложения, ключевое слово UNION может использоваться для извлечения данных из других таблиц базы данных. Это приводит к атаке SQL injection UNION attacks.

Ключевое слово UNION позволяет выполнить один или несколько дополнительных запросов SELECT и добавить результаты к исходному запросу. Например:
>SELECT a, b FROM table1 UNION SELECT c, d FROM table2

Этот SQL-запрос вернет один результирующий набор с двумя столбцами, содержащий значения из столбцов a и b в table1 и столбцов c и d в table2.

Чтобы *UNION* запрос работал, должны быть выполнены два ключевых требования:
* Каждый отдельный запрос должен возвращать одинаковое количество столбцов.
* Типы данных в каждом столбце должны быть совместимы между отдельными запросами.

Чтобы выполнить атаку объединения SQL-инъекций, вам необходимо убедиться, что ваша атака соответствует этим двум требованиям. Как правило, атака включает в себя выяснение:
* Сколько столбцов возвращается из исходного запроса?
* Какие столбцы в исходномм запросе, имеют подходящий тип данных для хранения результатов инъектированного запроса?

##### Определение количества столбцов с помощью SQL injection UNION attack
При выполнении атаки SQL injection UNION attack существует два эффективных метода определения количества столбцов, возвращаемых из исходного запроса.

Первый метод включает в себя введение ряда запросов *ORDER BY* и увеличение указанного индекса столбца до тех пор, пока не произойдет ошибка. Например, предполагая, что точка ввода является строкой в кавычках в выражении WHERE исходного запроса, вы бы отправили:
>' ORDER BY 1--

>' ORDER BY 2--

>' ORDER BY 3-

>etc.

Эта серия полезных нагрузок изменяет исходный запрос, чтобы упорядочить результаты по разным столбцам в наборе результатов. Столбец в запросе *ORDER BY* может быть указан по его индексу, поэтому вам не нужно знать имена каких-либо столбцов. Когда указанный индекс столбца превышает количество фактических столбцов в результирующем запросе, база данных возвращает ошибку, такую как:
>The ORDER BY position number 3 is out of range of the number of items in the select list.

Приложение может фактически вернуть ошибку базы данных в своем HTTP-ответе, или оно может вернуть общую ошибку, или просто не вернуть результатов. При условии, что вы можете обнаружить некоторую разницу в ответе приложения, вы можете определить, сколько столбцов возвращается из запроса.

Второй метод включает отправку серии полезных нагрузок *UNION SELECT* с указанием другого количества *NULL* значений:
>' UNION SELECT NULL--

>' UNION SELECT NULL,NULL--

>' UNION SELECT NULL,NULL,NULL--

>etc.

Если количество *NULL* не совпадает с количеством столбцов, база данных возвращает ошибку, например:
>All queries combined using a UNION, INTERSECT or EXCEPT operator must have an equal number of expressions in their target lists.

Опять же, приложение может фактически вернуть это сообщение об ошибке или просто вернуть общую ошибку или ничего не вернуть. Когда количество *NULL* совпадает с количеством столбцов, база данных возвращает дополнительную строку в результирующем наборе, содержащую нулевые значения в каждом столбце. Влияние на результирующий HTTP-ответ зависит от кода приложения. Если вам повезет, вы увидите в ответе некоторое дополнительное содержимое, например дополнительную строку в таблице HTML. В противном случае значения *NULL* могут вызвать другую ошибку, такую как исключение *NullPointerException*. В худшем случае ответ может быть неотличим от ответа, вызванного неправильным количеством *NULL*, что делает этот метод определения количества столбцов неэффективным.
>Заметка:

>* Причина использования *NULL* в качестве значений, возвращаемых из введенного запроса *SELECT*, заключается в том, что типы данных в каждом столбце должны быть совместимы между исходным и введенным запросами. Поскольку значение *NULL* преобразуется в каждый часто используемый тип данных, использование значения *NULL* увеличивает вероятность успешного выполнения полезной нагрузки при правильном подсчете столбцов.

>* В Oracle каждый запрос SELECT должен использовать ключевое слово *FROM* и указывать допустимую таблицу. В Oracle есть встроенная таблица под названием *dual*, которую можно использовать для этой цели. Таким образом, вводимые запросы в Oracle должны выглядеть следующим образом: 
<br/>' UNION SELECT NULL FROM DUAL--.

>* Описанные полезные нагрузки используют последовательность комментариев с двойным тире *--* для того, чтобы прокомментировать оставшуюся часть исходного запроса после точки ввода. В MySQL последовательность двойного тире должна сопровождаться пробелом. В качестве альтернативы для идентификации комментария можно использовать хэш-символ *#*.

##### Определение типа данных в столбце с помощью SQL injection UNION attack
Причина выполнения атаки SQL injection UNION attack заключается в том, чтобы иметь возможность извлекать результаты из введенного запроса. Как правило, интересные данные, которые вы хотите получить, будут в строковой форме, поэтому вам нужно найти один или несколько столбцов в исходных результатах запроса, тип данных которых соответствует строковым данным или совместим с ними.

Уже определив количество требуемых столбцов, вы можете проверить каждый столбец, чтобы проверить, может ли он содержать строковые данные, отправив серию полезных нагрузок *UNION SELECT*, которые по очереди помещают строковое значение в каждый столбец. Например, если запрос возвращает четыре столбца, вы должны отправить:
>' UNION SELECT 'a',NULL,NULL,NULL--

>' UNION SELECT NULL,'a',NULL,NULL--

>' UNION SELECT NULL,NULL,'a',NULL--

>' UNION SELECT NULL,NULL,NULL,'a'--

Если тип данных столбца несовместим со строковыми данными, введенный запрос вызовет ошибку базы данных, например:
>Conversion failed when converting the varchar value 'a' to data type int.

Если ошибка не возникает, и ответ приложения содержит некоторое дополнительное содержимое, включая введенное строковое значение, то соответствующий столбец подходит для извлечения строковых данных.
##### Использование SQL injection UNION attack для получения "интересных" данных
Когда вы определили количество столбцов, возвращаемых исходным запросом, и выяснили, какие столбцы могут содержать строковые данные, вы сможете получить интересные данные.
Предположим что:
* Исходный запрос возвращает два столбца, оба из которых могут содержать строковые данные.
* Точка ввода - это строка в кавычках в выражении *WHERE*.
* База данных содержит таблицу под названием *users* со столбцами *username* и *password*.

В этом случае вы можете получить содержимое таблицы "*users*", отправив следующий запрос:
>' UNION SELECT username, password FROM users--

Конечно, важнейшая информация, необходимая для выполнения этой атаки, заключается в том, что существует таблица под названием *Users* с двумя столбцами, называемыми *username* и *password*. Без этой информации вам пришлось бы пытаться угадать названия таблиц и столбцов. Фактически, все современные базы данных предоставляют способы изучения её структуры, чтобы определить, какие таблицы и столбцы она содержит.
##### Получение множества значений в один столбец
В отличии от предыдущего примера предположим, что запрос возвращает только один столбец.

Вы можете легко получить несколько значений вместе в этом одном столбце, объединив значения вместе, в идеале включив подходящий разделитель, позволяющий различать объединенные значения. Например, в Oracle вы можете отправить запрос:
>' UNION SELECT username || '~' || password FROM users--

При этом используются символы двойного пайпа ||, которые являются оператором конкатенации строк в Oracle. Введенный запрос объединяет значения полей имени пользователя и пароля, разделенных символом ~.

Результаты запроса позволят вам прочитать все имена пользователей и пароли, например:
>...

>administrator~s3cure

>wiener~peter

>carlos~montoya

>...

Обратите внимание, что разные базы данных используют разный синтаксис для выполнения конкатенации строк.
### Изучение базы данных
После первоначального выявления уязвимости SQL-инъекциям, как правило, полезно получить некоторую информацию о самой базе данных. Эта информация часто может проложить путь для дальнейшей эксплуатации.

Вы можете запросить сведения о версии базы данных. Способ, которым это делается, зависит от типа базы данных, поэтому вы можете определить тип базы данных, исходя из того, какой метод работает. Например, в Oracle вы можете выполнить:
>SELECT * FROM v$version

Вы также можете определить, какие таблицы базы данных существуют и какие столбцы они содержат. Например, в большинстве баз данных вы можете выполнить следующий запрос, чтобы вывести список таблиц:
>SELECT * FROM information_schema.tables
#### Запрос типа и версии базы данных
Различные базы данных предоставляют различные способы запроса их версии. Вам часто приходится пробовать различные запросы, чтобы найти тот, который работает, позволяя вам определить как тип, так и версию программного обеспечения базы данных.

Запросы для определения версии базы данных для некоторых популярных типов баз данных следующие:
| Database type |	Query |
| Microsoft, MySQL |	SELECT @@version |
| Oracle |	SELECT * FROM v$version |
| PostgreSQL |	SELECT version() |
Например, вы можете использовать *UNION attack* со следующими входными данными:
>' UNION SELECT @@version--

Инъекция может получить вывод, подобный следующему, подтверждающий, что база данных является Microsoft SQL Server и используемой версией:
>Microsoft SQL Server 2016 (SP2) (KB4052908) - 13.0.5026.0 (X64)<br/>
Mar 18 2018 09:11:49<br/>
Copyright (c) Microsoft Corporation<br/>
Standard Edition (64-bit) on Windows Server 2016 Standard 10.0 <X64> (Build 14393: ) (Hypervisor)<br/>
  
#### Перечисление содержимого базы данных
Большинство типов баз данных (за заметным исключением Oracle) имеют набор представлений, называемых информационной схемой, которые предоставляют информацию о базе данных.

Вы можете запросить *information_schema.tables*, чтобы получить список таблиц в базе данных:
>SELECT * FROM information_schema.tables
  
Запрос вернёт следующее:
>TABLE_CATALOG TABLE_SCHEMA TABLE_NAME TABLE_TYPE<br/>
=====================================================<br/>
MyDatabase dbo Products BASE TABLE<br/>
MyDatabase dbo Users BASE TABLE<br/>
MyDatabase dbo Feedback BASE TABLE<br/>

Этот вывод указывает, что существует три таблицы, называемые *Products*, *Users* и *Feedback*.

Затем вы можете запросить *information_schema.columns*, чтобы вывести список столбцов в отдельных таблицах:
>SELECT * FROM information_schema.columns WHERE table_name = 'Users'
  
Запрос вернёт следующее:
>TABLE_CATALOG TABLE_SCHEMA TABLE_NAME COLUMN_NAME DATA_TYPE<br/>
=================================================================<br/>
MyDatabase dbo Users UserId int<br/>
MyDatabase dbo Users Username varchar<br/>
MyDatabase dbo Users Password varchar<br/>

Этот вывод показывает столбцы в указанной таблице и тип данных каждого столбца.
#### Эквивалент *information_schema* в Oracle
В Oracle вы можете получить ту же информацию с помощью немного других запросов.

Вы можете перечислить таблицы, запросив *all_tables*:
>SELECT * FROM all_tables

И вы можете перечислить столбцы, запросив *all_tab_columns*:
>SELECT * FROM all_tab_columns WHERE table_name = 'USERS'
### Уязвимости Blind SQL инъекции
Многие случаи SQL-инъекций являются слепыми уязвимостями. Это означает, что приложение не возвращает результаты SQL-запроса или сведения о каких-либо ошибках базы данных в своих ответах. Слепые уязвимости все еще могут быть использованы для доступа к несанкционированным данным, но используемые методы, как правило, более сложны и сложны в исполнении.

В зависимости от характера уязвимости и используемой базы данных для использования уязвимостей слепой инъекции SQL могут быть использованы следующие методы:
* Вы можете изменить логику запроса, чтобы вызвать обнаруживаемую разницу в ответе приложения в зависимости от истинности одного условия. Это может включать введение нового условия в некоторую Булеву логику или условное срабатывание ошибки, такой как деление на ноль.
* Вы можете условно вызвать временную задержку в обработке запроса, что позволит вам определить истинность условия на основе времени, которое требуется приложению для ответа.
* Вы можете запустить внеполосное(?) сетевое взаимодействие, используя методы OAST. Эта техника чрезвычайно мощна и работает в ситуациях, когда другие техники этого не делают. Часто вы можете напрямую извлекать данные по внешнему каналу, например, помещая данные в поиск DNS для домена, которым вы управляете.

### Как детектировать уязвимости SQL инъекциям
Большинство уязвимостей SQL-инъекций можно быстро и надежно обнаружить с помощью сканера веб-уязвимостей Burp Suite.

SQL инъекции можгут быть обнаружены вручную с помощью систематического набора тестов для каждой точки входа в приложение. Обычно это включает в себя:
* Отправка символа одинарной кавычки ' и поиск ошибок или других аномалий.
* Отправка некоторого специфичного для SQL синтаксиса, который вычисляет базовое (исходное) значение точки входа и другое значение, и поиск систематических различий в результирующих ответах приложения.
* Отправка логических условий, таких как *OR 1=1* и *OR 1=2*, и поиск различий в ответах приложения.
* Отправка полезных нагрузок, предназначенных для запуска временных задержек при выполнении SQL-запроса, и поиск различий во времени, затрачиваемом на ответ.
* Отправка полезных нагрузок OAST, предназначенных для запуска внеполосного(?) сетевого взаимодействия при выполнении в рамках SQL-запроса, и мониторинг любых результирующих взаимодействий.
### SQL инъекция в разные части запроса
Большинство уязвимостей при SQL инъекции возникают в выражении *WHERE* запроса *SELECT*. Этот тип SQL-инъекции, как правило, хорошо понятен опытным тестировщикам.

Но уязвимости SQL-инъекций в принципе могут возникать в любом месте запроса и в разных типах запросов. Наиболее распространенными другими местами, где возникает SQL-инъекция, являются:
* В операторах *UPDATE*, в пределах обновляемых значений или в выражении *WHERE*.
* В операторах *INSERT*, в пределах вставляемых значений.
* В операторах *SELECT*, в имени таблицы или столбца.
* В операторах *SELECT* в предложении *ORDER BY*.
### SQL инъекции второго порядка
SQL инъекции первого порядка возникает, когда приложение принимает вводимые пользователем данные из HTTP-запроса и в ходе обработки этого запроса включает вводимые данные в SQL-запрос небезопасным способом.

При SQL инъекции второго порядка (также известном как *stored* SQL инъекция) приложение принимает вводимые пользователем данные из HTTP-запроса и сохраняет их для дальнейшего использования. Обычно это делается путем помещения входных данных в базу данных, но в том месте, где хранятся данные, никакой уязвимости не возникает. Позже, при обработке другого HTTP-запроса, приложение извлекает сохраненные данные и включает их в SQL-запрос небезопасным способом.

SQL инъекции второго порядка часто возникает в ситуациях, когда разработчики знают об уязвимостях внедрения SQL и поэтому безопасно обрабатывают первоначальное размещение входных данных в базе данных. Когда данные позже обрабатываются, они считаются безопасными, поскольку ранее они были безопасно помещены в базу данных. На этом этапе данные обрабатываются небезопасным способом, потому что разработчик ошибочно считает их надежными.
![](https://portswigger.net/web-security/images/second-order-sql-injection.svg)
### Факторы, зависящие от базы данных
Некоторые основные функции языка SQL реализованы одинаковым образом на популярных платформах баз данных, и поэтому многие способы обнаружения и использования уязвимостей SQL-инъекций одинаково работают в разных типах баз данных.

Однако между общими базами данных также существует множество различий. Это означает, что некоторые методы обнаружения и использования SQL-инъекций работают по-разному на разных платформах. Например:
* Синтаксис для объединения строк.
* Комментарии.
* Пакетные (или стековые) запросы.
* API для конкретной платформы.
* Сообщения об ошибках.

### Как предотвратить SQL инъекции
Большинство случаев SQL инъекций можно предотвратить, используя параметризованные запросы (также известные как подготовленные инструкции) вместо объединения строк в запросе.

Следующий код уязвим для SQL инъекции, поскольку вводимые пользователем данные объединяются непосредственно в запрос:
```php
String query = "SELECT * FROM products WHERE category = '"+ input + "'";
Statement statement = connection.createStatement();
ResultSet resultSet = statement.executeQuery(query);
```

Этот код можно легко переписать таким образом, чтобы пользовательский ввод не мешал структуре запроса:
```php
PreparedStatement statement = connection.prepareStatement("SELECT * FROM products WHERE category = ?");
statement.setString(1, input);
ResultSet resultSet = statement.executeQuery();
```

Параметризованные запросы можно использовать в любой ситуации, когда ненадежные входные данные отображаются в виде данных в запросе, включая выражения *WHERE* и значения в операторе *INSERT* или *UPDATE*. Их нельзя использовать для обработки ненадежных входных данных в других частях запроса, таких как имена таблиц или столбцов или выражении *ORDER BY*. Функции приложения, которые помещают ненадежные данные в эти части запроса, должны будут использовать другой подход, такой как включение разрешенных входных значений в белый список или использование другой логики для обеспечения требуемого поведения.

Чтобы параметризованный запрос эффективно предотвращал SQL инъекции, строка, используемая в запросе, всегда должна быть жестко запрограммированной константой и никогда не должна содержать никаких переменных данных из любого источника. Не поддавайтесь искушению решать в каждом конкретном случае, является ли элемент данных надежным, и продолжайте использовать объединение строк в запросе для случаев, которые считаются безопасными. Слишком легко ошибиться в отношении возможного происхождения данных или внести изменения в другой код, чтобы нарушить предположения о том, какие данные испорчены.
