## SQL Injections (source: Portswigger academy):
### Что такое SQL инъекции
SQL инъекции - это уязвимость веб-безопасности, которая позволяет злоумышленнику вмешиваться в запросы, которые приложение делает к своей базе данных. Как правило, это позволяет злоумышленнику просматривать данные, которые они обычно не могут получить. Это может включать данные, принадлежащие другим пользователям, или любые другие данные, к которым может получить доступ само приложение. Во многих случаях злоумышленник может изменить или удалить эти данные, что приведет к постоянным изменениям содержимого или поведения приложения.
В некоторых ситуациях злоумышленник может усилить атаку с использованием SQL-инъекции, чтобы скомпрометировать базовый сервер или другую внутреннюю инфраструктуру, или выполнить атаку с отказом в обслуживании (dos).
### Какое влияние может оказать успешная SQL-инъекция?
Успешная атака с использованием SQL-инъекции может привести к несанкционированному доступу к конфиденциальным данным, таким как пароли, данные кредитной карты или личная информация пользователя. Многие громкие утечки данных в последние годы стали результатом атак с использованием SQL-инъекций, что привело к ущербу репутации и штрафам регулирующих органов. В некоторых случаях злоумышленник может получить постоянный бэкдор в системы организации, что приведет к долгосрочной эксплуатации, которая может оставаться незамеченной в течение длительного периода.
### Примеры SQL-инъекций
Существует большое разнообразие уязвимостей, атак и методов внедрения SQL, которые возникают в различных ситуациях. Некоторые распространенные примеры SQL-инъекций включают:
* Извлечение скрытых данных, где вы можете изменить SQL-запрос, чтобы вернуть дополнительные результаты.
* Подрыв логики приложения, где вы можете изменить запрос, чтобы вмешаться в логику приложения.
* *UNION* атаки, в которых вы можете извлекать данные из разных таблиц базы данных.
* Изучение базы данных, из которой можно извлечь информацию о версии и структуре базы данных.
* Слепая инъекция SQL, при которой результаты управляемого вами запроса не возвращаются в ответах приложения.
### Извлечение скрытых данных
Рассмотрим приложение для покупок, которое отображает товары в разных категориях. Когда пользователь нажимает на категорию *Gifts*, его браузер запрашивает URL-адрес:
>https://insecure-website.com/products?category=Gifts'-- 

Это заставляет приложение выполнять SQL-запрос для получения сведений о соответствующих продуктах из базы данных:
>SELECT * FROM products WHERE category = 'Gifts' AND released = 1

Этот запрос запрашивает у базы данных следущие данные:
* все данные («*»)
* из таблицы *products*
* где категория продуктов *Gifts*
* и released is 1

Ограничение released = 1 используется для скрытия продуктов, которые не выпущены. Для неизданных продуктов, предполагается released = 0.

Приложение не реализует никаких средств защиты от атак с использованием SQL-инъекций, поэтому злоумышленник может создать атаку, подобную:
>https://insecure-website.com/products?category=Gifts'--

В результате будет следующий SQL запрос:
>SELECT * FROM products WHERE category = 'Gifts'--' AND released = 1

Ключевым моментом здесь является то, что последовательность двойных тире -- это индикатор комментариев в SQL и означает, что остальная часть запроса интерпретируется как комментарий. Это эффективно удаляет оставшуюся часть запроса, поэтому он больше не включает *AND released = 1*. Это означает, что отображаются все продукты, включая неизданные.

Идя дальше, злоумышленник может заставить приложение отображать все товары в любой категории, включая категории, о которых они не знают:
>https://insecure-website.com/products?category=Gifts'+OR+1=1--

В результате будет следующий SQL запрос:
>SELECT * FROM products WHERE category = 'Gifts' OR 1=1--' AND released = 1

Измененный запрос вернет все товары, в которых либо категория является *Gifts*, либо 1 равно 1. Поскольку 1=1 всегда истинно, запрос вернет все элементы.
### Подрыв логики приложения
Рассмотрим приложение, которое позволяет пользователям входить в систему с именем пользователя и паролем. Если пользователь вводит имя пользователя *wiener* и пароль *bluecheese*, приложение проверяет учетные данные, выполняя следующий SQL-запрос:
>SELECT * FROM users WHERE username = 'wiener' AND password = 'bluecheese'

Если запрос возвращает сведения о пользователе, то вход в систему выполнен успешно. В противном случае он отклоняется.

Здесь злоумышленник может войти в систему как любой пользователь без пароля, просто используя последовательность комментариев SQL-чтобы удалить проверку пароля из выражения *WHERE* запроса. Например, отправив имя пользователя **administrator'--** и пустой пароль, вы получите следующий запрос:
>SELECT * FROM users WHERE username = 'administrator'--' AND password = ''

Этот запрос возвращает пользователя с именем администратора и успешно регистрирует злоумышленника как этого пользователя
### Извлечение данных из других таблиц базы данных
В случаях, когда результаты SQL-запроса возвращаются в ответах приложения, злоумышленник может использовать уязвимость SQL-инъекций для извлечения данных из других таблиц базы данных. Это делается с помощью ключевого слова *UNION*, которое позволяет выполнить дополнительный запрос *SELECT* и добавить результаты к исходному запросу.

Например, если приложение выполняет следующий запрос, содержащий введимое пользователем "Gifts":
>SELECT name, description FROM products WHERE category = 'Gifts'

тогда атакующий может внедрить:
>' UNION SELECT username, password FROM users--

Это приведет к тому, что приложение вернет все имена пользователей и пароли вместе с названиями и описаниями продуктов.
#### SQL injection UNION attacks
Когда приложение уязвимо для SQL инъекций и результаты запроса возвращаются в ответах приложения, ключевое слово UNION может использоваться для извлечения данных из других таблиц базы данных. Это приводит к атаке SQL injection UNION attacks.

Ключевое слово UNION позволяет выполнить один или несколько дополнительных запросов SELECT и добавить результаты к исходному запросу. Например:
>SELECT a, b FROM table1 UNION SELECT c, d FROM table2

Этот SQL-запрос вернет один результирующий набор с двумя столбцами, содержащий значения из столбцов a и b в table1 и столбцов c и d в table2.

Чтобы *UNION* запрос работал, должны быть выполнены два ключевых требования:
* Каждый отдельный запрос должен возвращать одинаковое количество столбцов.
* Типы данных в каждом столбце должны быть совместимы между отдельными запросами.

Чтобы выполнить атаку объединения SQL-инъекций, вам необходимо убедиться, что ваша атака соответствует этим двум требованиям. Как правило, атака включает в себя выяснение:
* Сколько столбцов возвращается из исходного запроса?
* Какие столбцы в исходномм запросе, имеют подходящий тип данных для хранения результатов инъектированного запроса?

##### Определение количества столбцов с помощью SQL injection UNION attack
При выполнении атаки SQL injection UNION attack существует два эффективных метода определения количества столбцов, возвращаемых из исходного запроса.

Первый метод включает в себя введение ряда запросов *ORDER BY* и увеличение указанного индекса столбца до тех пор, пока не произойдет ошибка. Например, предполагая, что точка ввода является строкой в кавычках в выражении WHERE исходного запроса, вы бы отправили:
>' ORDER BY 1--

>' ORDER BY 2--

>' ORDER BY 3-

>etc.

Эта серия полезных нагрузок изменяет исходный запрос, чтобы упорядочить результаты по разным столбцам в наборе результатов. Столбец в запросе *ORDER BY* может быть указан по его индексу, поэтому вам не нужно знать имена каких-либо столбцов. Когда указанный индекс столбца превышает количество фактических столбцов в результирующем запросе, база данных возвращает ошибку, такую как:
>The ORDER BY position number 3 is out of range of the number of items in the select list.

Приложение может фактически вернуть ошибку базы данных в своем HTTP-ответе, или оно может вернуть общую ошибку, или просто не вернуть результатов. При условии, что вы можете обнаружить некоторую разницу в ответе приложения, вы можете определить, сколько столбцов возвращается из запроса.

Второй метод включает отправку серии полезных нагрузок *UNION SELECT* с указанием другого количества *NULL* значений:
>' UNION SELECT NULL--

>' UNION SELECT NULL,NULL--

>' UNION SELECT NULL,NULL,NULL--

>etc.

Если количество *NULL* не совпадает с количеством столбцов, база данных возвращает ошибку, например:
>All queries combined using a UNION, INTERSECT or EXCEPT operator must have an equal number of expressions in their target lists.

Опять же, приложение может фактически вернуть это сообщение об ошибке или просто вернуть общую ошибку или ничего не вернуть. Когда количество *NULL* совпадает с количеством столбцов, база данных возвращает дополнительную строку в результирующем наборе, содержащую нулевые значения в каждом столбце. Влияние на результирующий HTTP-ответ зависит от кода приложения. Если вам повезет, вы увидите в ответе некоторое дополнительное содержимое, например дополнительную строку в таблице HTML. В противном случае значения *NULL* могут вызвать другую ошибку, такую как исключение *NullPointerException*. В худшем случае ответ может быть неотличим от ответа, вызванного неправильным количеством *NULL*, что делает этот метод определения количества столбцов неэффективным.
>Заметка:

>* Причина использования *NULL* в качестве значений, возвращаемых из введенного запроса *SELECT*, заключается в том, что типы данных в каждом столбце должны быть совместимы между исходным и введенным запросами. Поскольку значение *NULL* преобразуется в каждый часто используемый тип данных, использование значения *NULL* увеличивает вероятность успешного выполнения полезной нагрузки при правильном подсчете столбцов.

>* В Oracle каждый запрос SELECT должен использовать ключевое слово *FROM* и указывать допустимую таблицу. В Oracle есть встроенная таблица под названием *dual*, которую можно использовать для этой цели. Таким образом, вводимые запросы в Oracle должны выглядеть следующим образом: 
<br/>' UNION SELECT NULL FROM DUAL--.

>* Описанные полезные нагрузки используют последовательность комментариев с двойным тире *--* для того, чтобы прокомментировать оставшуюся часть исходного запроса после точки ввода. В MySQL последовательность двойного тире должна сопровождаться пробелом. В качестве альтернативы для идентификации комментария можно использовать хэш-символ *#*.

##### Определение типа данных в столбце с помощью SQL injection UNION attack
Причина выполнения атаки SQL injection UNION attack заключается в том, чтобы иметь возможность извлекать результаты из введенного запроса. Как правило, интересные данные, которые вы хотите получить, будут в строковой форме, поэтому вам нужно найти один или несколько столбцов в исходных результатах запроса, тип данных которых соответствует строковым данным или совместим с ними.

Уже определив количество требуемых столбцов, вы можете проверить каждый столбец, чтобы проверить, может ли он содержать строковые данные, отправив серию полезных нагрузок *UNION SELECT*, которые по очереди помещают строковое значение в каждый столбец. Например, если запрос возвращает четыре столбца, вы должны отправить:
>' UNION SELECT 'a',NULL,NULL,NULL--

>' UNION SELECT NULL,'a',NULL,NULL--

>' UNION SELECT NULL,NULL,'a',NULL--

>' UNION SELECT NULL,NULL,NULL,'a'--

Если тип данных столбца несовместим со строковыми данными, введенный запрос вызовет ошибку базы данных, например:
>Conversion failed when converting the varchar value 'a' to data type int.

Если ошибка не возникает, и ответ приложения содержит некоторое дополнительное содержимое, включая введенное строковое значение, то соответствующий столбец подходит для извлечения строковых данных.
##### Использование SQL injection UNION attack для получения "интересных" данных
Когда вы определили количество столбцов, возвращаемых исходным запросом, и выяснили, какие столбцы могут содержать строковые данные, вы сможете получить интересные данные.
Предположим что:
* Исходный запрос возвращает два столбца, оба из которых могут содержать строковые данные.
* Точка ввода - это строка в кавычках в выражении *WHERE*.
* База данных содержит таблицу под названием *users* со столбцами *username* и *password*.

В этом случае вы можете получить содержимое таблицы "*users*", отправив следующий запрос:
>' UNION SELECT username, password FROM users--

Конечно, важнейшая информация, необходимая для выполнения этой атаки, заключается в том, что существует таблица под названием *Users* с двумя столбцами, называемыми *username* и *password*. Без этой информации вам пришлось бы пытаться угадать названия таблиц и столбцов. Фактически, все современные базы данных предоставляют способы изучения её структуры, чтобы определить, какие таблицы и столбцы она содержит.
##### Получение множества значений в один столбец
В отличии от предыдущего примера предположим, что запрос возвращает только один столбец.

Вы можете легко получить несколько значений вместе в этом одном столбце, объединив значения вместе, в идеале включив подходящий разделитель, позволяющий различать объединенные значения. Например, в Oracle вы можете отправить запрос:
>' UNION SELECT username || '~' || password FROM users--

При этом используются символы двойного пайпа ||, которые являются оператором конкатенации строк в Oracle. Введенный запрос объединяет значения полей имени пользователя и пароля, разделенных символом ~.

Результаты запроса позволят вам прочитать все имена пользователей и пароли, например:
>...

>administrator~s3cure

>wiener~peter

>carlos~montoya

>...

Обратите внимание, что разные базы данных используют разный синтаксис для выполнения конкатенации строк.
### Изучение базы данных
После первоначального выявления уязвимости SQL-инъекциям, как правило, полезно получить некоторую информацию о самой базе данных. Эта информация часто может проложить путь для дальнейшей эксплуатации.

Вы можете запросить сведения о версии базы данных. Способ, которым это делается, зависит от типа базы данных, поэтому вы можете определить тип базы данных, исходя из того, какой метод работает. Например, в Oracle вы можете выполнить:
>SELECT * FROM v$version

Вы также можете определить, какие таблицы базы данных существуют и какие столбцы они содержат. Например, в большинстве баз данных вы можете выполнить следующий запрос, чтобы вывести список таблиц:
>SELECT * FROM information_schema.tables

